{% extends "base.html" %}

{% block styles %}
<!-- Leaflet CSS for maps -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<!-- MarkerCluster CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
<!-- Leaflet Time Dimension CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.control.min.css" />
<!-- Daterangepicker CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
<!-- Chart.js CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.css">
<style>
    #map {
        height: 70vh;
        width: 100%;
        border-radius: 12px;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
    }
    .info-table {
        max-height: 250px;
        overflow-y: auto;
        scrollbar-width: thin;
    }
    .stats-badge {
        font-size: 14px;
        transition: all 0.2s ease;
    }
    .waste-type-label {
        text-transform: capitalize;
    }
    .map-container {
        position: relative;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 20px rgba(0,0,0,0.08);
    }
    .map-overlay {
        position: absolute;
        top: 15px;
        right: 15px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.92);
        padding: 12px 16px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        font-size: 14px;
        max-width: 220px;
        transition: all 0.3s ease;
    }
    .map-overlay:hover {
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18);
        background: rgba(255, 255, 255, 0.97);
    }
    .card {
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        border: none;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        border-radius: 12px;
        overflow: hidden;
    }
    .card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
    }
    .card-header {
        border-bottom: none;
        padding: 15px 20px;
    }
    .list-group-item {
        padding: 12px 16px;
        border-left: none;
        border-right: none;
    }
    .list-group-item:first-child {
        border-top: none;
    }
    .btn {
        border-radius: 8px;
        padding: 8px 16px;
        transition: all 0.2s ease;
        font-weight: 500;
    }
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    /* New styles for enhanced map page */
    .map-controls {
        position: absolute;
        top: 15px;
        left: 15px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.92);
        padding: 12px 16px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        max-width: 320px;
        transition: all 0.3s ease;
    }
    .map-controls:hover {
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18);
        background: rgba(255, 255, 255, 0.97);
    }
    .filter-badge {
        font-size: 12px;
        padding: 6px 12px;
        margin-right: 5px;
        margin-bottom: 5px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .filter-badge:hover {
        transform: translateY(-2px);
    }
    .filter-badge.active {
        box-shadow: 0 0 0 2px #fff, 0 0 0 4px #007bff;
    }
    .toggle-btn {
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        color: #495057;
        margin-right: 5px;
    }
    .toggle-btn.active {
        background: #2D6A4F;
        color: white;
        border-color: #2D6A4F;
    }
    .chart-container {
        width: 100%;
        height: 250px;
        margin-bottom: 20px;
    }
    .nav-tabs .nav-link.active {
        border-color: transparent;
        border-bottom: 3px solid #2D6A4F;
        font-weight: 600;
    }
    .nav-tabs .nav-link {
        color: #495057;
        border: none;
        padding: 12px 15px;
        transition: all 0.3s ease;
    }
    .nav-tabs .nav-link:hover {
        border-color: transparent;
        border-bottom: 3px solid rgba(45, 106, 79, 0.3);
    }
    .nav-tabs {
        border-bottom: 1px solid #dee2e6;
        margin-bottom: 15px;
    }
    .cluster-marker {
        background-color: rgba(45, 106, 79, 0.8);
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.5);
    }
    .timeline-slider {
        width: 100%;
        margin: 10px 0;
    }
    .weight-range {
        margin-top: 10px;
    }
    .search-bar {
        margin-bottom: 15px;
    }
    .daterangepicker td.active {
        background-color: #2D6A4F !important;
    }
    .route-line {
        stroke: #2D6A4F;
        stroke-width: 3;
        stroke-opacity: 0.7;
        stroke-dasharray: 5, 8;
        animation: dash 30s linear infinite;
    }
    @keyframes dash {
        to {
            stroke-dashoffset: -1000;
        }
    }
    .leaflet-popup-content-wrapper {
        border-radius: 8px;
    }
    .custom-tooltip {
        background-color: rgba(45, 106, 79, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-weight: 500;
    }
    .heatmap-toggle.active {
        background-color: #FF7F50;
        border-color: #FF7F50;
    }
    /* Mobile optimizations */
    @media (max-width: 767px) {
        .map-controls, .map-overlay {
            position: relative;
            top: auto;
            left: auto;
            right: auto;
            max-width: 100%;
            margin-bottom: 15px;
        }
        #map {
            height: 50vh;
        }
        .card {
            margin-bottom: 15px;
        }
    }
    /* Map legend style */
    .map-legend {
        position: absolute;
        bottom: 30px;
        right: 15px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.92);
        padding: 12px 16px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        font-size: 14px;
        max-width: 220px;
        transition: all 0.3s ease;
    }
    .map-legend:hover {
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18);
        background: rgba(255, 255, 255, 0.97);
    }
    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
    }
    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 10px;
        border: 1px solid rgba(0,0,0,0.2);
    }
    .legend-title {
        font-weight: bold;
        margin-bottom: 8px;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: 5px;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <div class="card shadow">
            <div class="card-header bg-gradient bg-success text-white">
                <div class="d-flex justify-content-between align-items-center">
                    <h4 class="mb-0"><i class="fas fa-map-marker-alt me-2"></i>Emptying Locations Map</h4>
                    <div>
                        <button class="btn btn-light btn-sm" id="exportCsv">
                            <i class="fas fa-download me-1"></i>Export CSV
                        </button>
                        <button class="btn btn-light btn-sm ms-2" id="toggleFullscreen">
                            <i class="fas fa-expand me-1"></i>Fullscreen
                        </button>
                    </div>
                </div>
            </div>
            <div class="card-body p-0">
                <div class="map-container">
                    <!-- Map controls overlay -->
                    <div class="map-controls d-none d-md-block">
                        <h6 class="mb-3"><i class="fas fa-filter me-2"></i>Filters</h6>
                        
                        <!-- Search bar -->
                        <div class="search-bar">
                            <div class="input-group input-group-sm">
                                <span class="input-group-text"><i class="fas fa-search"></i></span>
                                <input type="text" class="form-control" id="searchTagCode" placeholder="Search tag code...">
                            </div>
                        </div>
                        
                        <!-- Filter pills for waste types -->
                        <div class="mb-3">
                            <small class="d-block mb-2">Waste Types:</small>
                            <div id="wasteTypeFilters">
                                <span class="badge bg-secondary filter-badge active" data-filter="all">All</span>
                                {% for waste_type, count in stats.waste_types.items() %}
                                    {% if waste_type and count > 0 %}
                                        <span class="badge filter-badge waste-type-label 
                                            {% if 'plastic' in waste_type %}bg-warning
                                            {% elif 'paper' in waste_type %}bg-primary
                                            {% elif 'glass' in waste_type %}bg-success
                                            {% elif 'organic' in waste_type %}bg-success
                                            {% elif 'metal' in waste_type %}bg-info
                                            {% else %}bg-danger{% endif %}"
                                            data-filter="{{ waste_type }}">
                                            {{ waste_type }} ({{ count }})
                                        </span>
                                    {% endif %}
                                {% endfor %}
                            </div>
                        </div>
                        
                        <!-- Date range picker -->
                        <div class="mb-3">
                            <small class="d-block mb-2">Date Range:</small>
                            <input type="text" class="form-control form-control-sm" id="daterange" placeholder="Select dates...">
                        </div>
                        
                        <!-- Weight range slider -->
                        <div class="weight-range">
                            <small class="d-block mb-2">Weight Range (kg):</small>
                            <div class="d-flex align-items-center">
                                <span id="minWeight" class="me-2">0</span>
                                <input type="range" class="form-range timeline-slider" id="weightRangeSlider" min="0" max="300" step="10" value="0">
                                <span id="maxWeight" class="ms-2">300</span>
                            </div>
                        </div>
                        
                        <!-- Visualization toggles -->
                        <div class="mt-3">
                            <small class="d-block mb-2">Visualization:</small>
                            <button class="toggle-btn active" id="clusterToggle"><i class="fas fa-object-group me-1"></i>Clusters</button>
                            <button class="toggle-btn heatmap-toggle" id="heatmapToggle"><i class="fas fa-fire me-1"></i>Heatmap</button>
                            <button class="toggle-btn" id="routeToggle"><i class="fas fa-route me-1"></i>Route</button>
                        </div>
                        
                        <!-- Reset filters button -->
                        <div class="mt-3">
                            <button class="btn btn-sm btn-outline-danger w-100" id="resetFilters">
                                <i class="fas fa-undo me-1"></i>Reset All Filters
                            </button>
                        </div>
                    </div>
                    
                    <!-- The map -->
                    <div id="map"></div>
                    
                    <!-- Map legend -->
                    <div class="map-legend d-none d-md-block">
                        <div class="legend-title">Waste Types</div>
                        {% if legend_items %}
                            {% for item in legend_items %}
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: {{ item.color }};"></div>
                                <div>{{ item.name }}</div>
                            </div>
                            {% endfor %}
                                    {% else %}
                            <!-- Fallback if legend_items not passed -->
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: brown;"></div>
                                <div>Organic</div>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: grey;"></div>
                                <div>Residual</div>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: yellow;"></div>
                                <div>Plastic</div>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: dodgerblue;"></div>
                                <div>Paper</div>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: green;"></div>
                                <div>Glass</div>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: cadetblue;"></div>
                                <div>Metal</div>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: darkred;"></div>
                                <div>Electronic</div>
                                </div>
                            {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Mobile filters (collapsible) -->
<div class="card shadow mb-4 d-md-none">
    <div class="card-header bg-gradient bg-primary text-white" data-bs-toggle="collapse" data-bs-target="#mobileFilters" aria-expanded="false">
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0"><i class="fas fa-filter me-2"></i>Filters</h5>
            <i class="fas fa-chevron-down"></i>
        </div>
    </div>
    <div class="collapse" id="mobileFilters">
        <div class="card-body">
            <!-- Mobile search bar -->
            <div class="mb-3">
                <label for="searchTagCodeMobile" class="form-label">Search Tag Code</label>
                <div class="input-group">
                    <span class="input-group-text"><i class="fas fa-search"></i></span>
                    <input type="text" class="form-control" id="searchTagCodeMobile" placeholder="Enter tag code...">
                </div>
            </div>
            
            <!-- Mobile waste type filters -->
            <div class="mb-3">
                <label class="form-label">Waste Types</label>
                <div id="mobileWasteTypeFilters">
                    <span class="badge bg-secondary filter-badge active" data-filter="all">All</span>
                    {% for waste_type, count in stats.waste_types.items() %}
                        {% if waste_type and count > 0 %}
                            <span class="badge filter-badge waste-type-label 
                                {% if 'plastic' in waste_type %}bg-warning
                                {% elif 'paper' in waste_type %}bg-primary
                                {% elif 'glass' in waste_type %}bg-success
                                {% elif 'organic' in waste_type %}bg-success
                                {% elif 'metal' in waste_type %}bg-info
                                {% else %}bg-danger{% endif %}"
                                data-filter="{{ waste_type }}">
                                {{ waste_type }} ({{ count }})
                            </span>
                        {% endif %}
                    {% endfor %}
                </div>
            </div>
            
            <!-- Mobile date range picker -->
            <div class="mb-3">
                <label for="daterangeMobile" class="form-label">Date Range</label>
                <input type="text" class="form-control" id="daterangeMobile" placeholder="Select dates...">
            </div>
            
            <!-- Mobile weight range slider -->
            <div class="mb-3">
                <label class="form-label">Weight Range (kg)</label>
                <div class="d-flex align-items-center">
                    <span id="minWeightMobile" class="me-2">0</span>
                    <input type="range" class="form-range" id="weightRangeSliderMobile" min="0" max="300" step="10" value="0">
                    <span id="maxWeightMobile" class="ms-2">300</span>
                </div>
            </div>
            
            <!-- Mobile visualization toggles -->
            <div class="mb-3">
                <label class="form-label">Visualization</label>
                <div class="d-flex flex-wrap">
                    <button class="toggle-btn active me-2 mb-2" id="clusterToggleMobile"><i class="fas fa-object-group me-1"></i>Clusters</button>
                    <button class="toggle-btn heatmap-toggle me-2 mb-2" id="heatmapToggleMobile"><i class="fas fa-fire me-1"></i>Heatmap</button>
                    <button class="toggle-btn me-2 mb-2" id="routeToggleMobile"><i class="fas fa-route me-1"></i>Route</button>
                </div>
            </div>
            
            <!-- Mobile reset filters button -->
            <button class="btn btn-outline-danger w-100" id="resetFiltersMobile">
                <i class="fas fa-undo me-1"></i>Reset All Filters
            </button>
        </div>
    </div>
</div>

<!-- Data Analytics Tab Card -->
<div class="card shadow mb-4">
    <div class="card-header bg-gradient bg-primary text-white">
        <h5 class="mb-0"><i class="fas fa-chart-bar me-2"></i>Data Analytics</h5>
    </div>
    <div class="card-body">
        <ul class="nav nav-tabs" id="analyticsTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="stats-tab" data-bs-toggle="tab" data-bs-target="#stats" type="button" role="tab" aria-controls="stats" aria-selected="true">Statistics</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="charts-tab" data-bs-toggle="tab" data-bs-target="#charts" type="button" role="tab" aria-controls="charts" aria-selected="false">Charts</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="table-tab" data-bs-toggle="tab" data-bs-target="#table" type="button" role="tab" aria-controls="table" aria-selected="false">Data Table</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="timeline-tab" data-bs-toggle="tab" data-bs-target="#timeline" type="button" role="tab" aria-controls="timeline" aria-selected="false">Timeline</button>
            </li>
        </ul>
        
        <div class="tab-content mt-3" id="analyticsTabsContent">
            <!-- Statistics Tab -->
            <div class="tab-pane fade show active" id="stats" role="tabpanel" aria-labelledby="stats-tab">
                <div class="row">
                    <div class="col-md-6">
                        <div class="card bg-light mb-3">
                            <div class="card-body">
                                <h6 class="card-title"><i class="fas fa-info-circle me-2"></i>General Statistics</h6>
                                <ul class="list-group list-group-flush">
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        Total Records
                                        <span class="badge bg-primary rounded-pill stats-badge">{{ stats.total_records }}</span>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        Valid Coordinates
                                        <span class="badge bg-success rounded-pill stats-badge">{{ stats.valid_coords }}</span>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        Invalid Coordinates
                                        <span class="badge bg-danger rounded-pill stats-badge">{{ stats.total_records - stats.valid_coords }}</span>
                                    </li>
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        Total Waste Weight
                                        <span class="badge bg-info rounded-pill stats-badge" id="totalWeight">Calculating...</span>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card bg-light mb-3">
                            <div class="card-body">
                                <h6 class="card-title"><i class="fas fa-trash-alt me-2"></i>Waste Types</h6>
                                <ul class="list-group list-group-flush">
                                    {% for waste_type, count in stats.waste_types.items() %}
                                    <li class="list-group-item d-flex justify-content-between align-items-center">
                                        <span class="waste-type-label">{{ waste_type if waste_type else 'Unknown' }}</span>
                                        <span class="badge bg-info rounded-pill stats-badge">{{ count }}</span>
                                    </li>
                                    {% endfor %}
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Charts Tab -->
            <div class="tab-pane fade" id="charts" role="tabpanel" aria-labelledby="charts-tab">
                <div class="row">
                    <div class="col-md-6">
                        <div class="card mb-3">
                            <div class="card-body">
                                <h6 class="card-title">Waste Type Distribution</h6>
                                <div class="chart-container">
                                    <canvas id="wasteTypeChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card mb-3">
                            <div class="card-body">
                                <h6 class="card-title">Weight Distribution</h6>
                                <div class="chart-container">
                                    <canvas id="weightChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Data Table Tab -->
            <div class="tab-pane fade" id="table" role="tabpanel" aria-labelledby="table-tab">
                <div class="input-group mb-3">
                    <span class="input-group-text"><i class="fas fa-search"></i></span>
                    <input type="text" class="form-control" id="tableSearch" placeholder="Search in table...">
                </div>
                <div class="info-table">
                    <table class="table table-striped table-hover" id="dataTable">
                        <thead>
                            <tr>
                                <th>Timestamp</th>
                                <th>Tag Code</th>
                                <th>Waste Type</th>
                                <th>Weight (kg)</th>
                                <th>Location</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for point in map_data.points %}
                            <tr data-tag="{{ point.tag_code }}" data-waste="{{ point.waste_type }}" data-weight="{{ point.weight }}">
                                <td>{{ point.timestamp }}</td>
                                <td>{{ point.tag_code }}</td>
                                <td class="waste-type-label">{{ point.waste_type }}</td>
                                <td>{{ point.weight }}</td>
                                <td>{{ point.lat|round(6) }}, {{ point.lng|round(6) }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Timeline Tab -->
            <div class="tab-pane fade" id="timeline" role="tabpanel" aria-labelledby="timeline-tab">
                <div class="mb-3">
                    <label for="timeSlider" class="form-label">Time Progress:</label>
                    <input type="range" class="form-range" id="timeSlider" min="0" max="100" value="0">
                    <div class="d-flex justify-content-between">
                        <small id="timeStart">Start Time</small>
                        <small id="timeEnd">End Time</small>
                    </div>
                </div>
                <div class="d-flex justify-content-center mb-3">
                    <button class="btn btn-sm btn-success me-2" id="playTimeline">
                        <i class="fas fa-play me-1"></i>Play
                    </button>
                    <button class="btn btn-sm btn-secondary me-2" id="pauseTimeline">
                        <i class="fas fa-pause me-1"></i>Pause
                    </button>
                    <button class="btn btn-sm btn-danger" id="resetTimeline">
                        <i class="fas fa-stop me-1"></i>Reset
                    </button>
                </div>
                <div class="card bg-light">
                    <div class="card-body">
                        <h6 class="card-title">Timeline Information</h6>
                        <div id="timelineInfo">
                            <p>Use the slider above to visualize the waste collection timeline. Press Play to animate the collection route automatically.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="mt-3">
    <a href="{{ url_for('index') }}" class="btn btn-secondary">
        <i class="fas fa-arrow-left me-2"></i>Back to Home
    </a>
</div>
{% endblock %}

{% block scripts %}
<!-- Leaflet JS for maps -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- MarkerCluster JS -->
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
<!-- Heatmap plugin -->
<script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
<!-- TimeDimension plugin -->
<script src="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.min.js"></script>
<!-- Moment.js for date handling -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
<!-- DateRangePicker JS -->
<script src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Get data from server-side
        var mapData = {{ map_data|tojson }};
        
        // Set initial variables
        let markersLayer = null;
        let heatLayer = null;
        let routeLayer = null;
        let filteredPoints = [...mapData.points];
        let activeFilters = {
            wasteType: 'all',
            dateRange: null,
            weightMin: 0,
            weightMax: 300,
            searchText: ''
        };
        
        // Create the map with center coordinates from server
        var map = L.map('map', {
            zoomControl: false,
            attributionControl: false
        }).setView(mapData.center, 10);
        
        // Add custom position for zoom control
        L.control.zoom({
            position: 'bottomright'
        }).addTo(map);
        
        // Add the OpenStreetMap tiles with a more modern style
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(map);
        
        // Initialize the markers
        initializeMarkers();
        
        // Calculate and display total weight
        calculateTotalWeight();
        
        // Initialize charts
        initializeCharts();
        
        // === UTILITY FUNCTIONS ===
        
        // Function to initialize markers on the map
        function initializeMarkers() {
            // Clear existing markers
            if (markersLayer) {
                map.removeLayer(markersLayer);
            }
            
            // Create new marker cluster group
            markersLayer = L.markerClusterGroup({
                chunkedLoading: true,
                maxClusterRadius: 50,
                iconCreateFunction: function(cluster) {
                    const count = cluster.getChildCount();
                    const size = count < 10 ? 'small' : count < 100 ? 'medium' : 'large';
                    return L.divIcon({
                        html: `<div class="cluster-marker" style="width:${size === 'small' ? 30 : size === 'medium' ? 40 : 50}px; height:${size === 'small' ? 30 : size === 'medium' ? 40 : 50}px;">${count}</div>`,
                        className: `marker-cluster marker-cluster-${size}`,
                        iconSize: L.point(size === 'small' ? 30 : size === 'medium' ? 40 : 50, size === 'small' ? 30 : size === 'medium' ? 40 : 50)
                    });
                }
            });
            
            // Add markers for each filtered point
            filteredPoints.forEach(point => {
                // Get waste type and corresponding color
                const wasteType = point.waste_type.toLowerCase();
                
                // Use standard waste type colors
                let markerColor = 'grey';  // Default color for unknown/residual waste
                
                if (wasteType.includes('organic') || wasteType.includes('food') || wasteType.includes('compost')) {
                    markerColor = 'brown';
                } else if (wasteType.includes('plastic')) {
                    markerColor = 'yellow';
                } else if (wasteType.includes('paper') || wasteType.includes('cardboard')) {
                    markerColor = 'dodgerblue';
                } else if (wasteType.includes('glass')) {
                    markerColor = 'green';
                } else if (wasteType.includes('residual') || wasteType.includes('non-recycl') || wasteType.includes('general')) {
                    markerColor = 'grey';
                } else if (wasteType.includes('metal') || wasteType.includes('aluminum')) {
                    markerColor = 'cadetblue';
                } else if (wasteType.includes('electronic') || wasteType.includes('ewaste')) {
                    markerColor = 'darkred';
                }
                
                // Create marker with appropriate color
                const marker = L.circleMarker([point.lat, point.lng], {
                    radius: 8,
                    fillColor: markerColor,
                    color: '#fff',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });
                
                // Create popup content
                const popupContent = `
                    <div class="marker-popup">
                        <h6>${point.tag_code}</h6>
                        <p><strong>Waste Type:</strong> ${point.waste_type}</p>
                        <p><strong>Weight:</strong> ${point.weight || 'N/A'} kg</p>
                        <p><strong>Date:</strong> ${point.timestamp}</p>
                    </div>
                `;
                
                // Set popup and tooltip
                marker.bindPopup(popupContent);
                marker.bindTooltip(point.tag_code, {
                    direction: 'top',
                    permanent: false,
                    opacity: 0.8,
                    className: 'custom-tooltip'
                });
                
                // Add to markers layer
                markersLayer.addLayer(marker);
                
                // Store reference to marker
                point.marker = marker;
            });
            
            // Add markers layer to map
            map.addLayer(markersLayer);
        }
        
        // Function to apply filters and update map
        function applyFilters() {
            // Start with all points
            filteredPoints = mapData.points.filter(point => {
                // Filter by waste type
                if (activeFilters.wasteType !== 'all' && 
                    point.waste_type.toLowerCase() !== activeFilters.wasteType.toLowerCase()) {
                    return false;
                }
                
                // Filter by weight range
                if (point.weight < activeFilters.weightMin || 
                    point.weight > activeFilters.weightMax) {
                    return false;
                }
                
                // Filter by date range
                if (activeFilters.dateRange) {
                    const pointDate = moment(point.timestamp, "YYYY-MM-DD HH:mm:ss");
                    if (!pointDate.isBetween(
                        activeFilters.dateRange[0], 
                        activeFilters.dateRange[1], null, '[]')) {
                        return false;
                    }
                }
                
                // Filter by search text
                if (activeFilters.searchText) {
                    const searchLower = activeFilters.searchText.toLowerCase();
                    if (!point.tag_code.toLowerCase().includes(searchLower)) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Update markers
            initializeMarkers();
            
            // Update heatmap if active
            if (heatLayer && map.hasLayer(heatLayer)) {
                updateHeatmap();
            }
            
            // Update route if active
            if (routeLayer && map.hasLayer(routeLayer)) {
                updateRoute();
            }
            
            // Update table rows visibility
            updateDataTable();
            
            // Recalculate total weight
            calculateTotalWeight();
            
            // Update charts
            updateCharts();
        }
        
        // Function to calculate and display total weight
        function calculateTotalWeight() {
            const totalWeight = filteredPoints.reduce((sum, point) => sum + parseFloat(point.weight || 0), 0);
            document.getElementById('totalWeight').textContent = totalWeight.toFixed(2) + ' kg';
        }
        
        // Function to initialize charts
        function initializeCharts() {
            // Waste Type Chart
            const wasteTypeCounts = {};
            mapData.points.forEach(point => {
                const wasteType = point.waste_type.toLowerCase();
                wasteTypeCounts[wasteType] = (wasteTypeCounts[wasteType] || 0) + 1;
            });
            
            const wasteTypeCtx = document.getElementById('wasteTypeChart').getContext('2d');
            const wasteTypeChart = new Chart(wasteTypeCtx, {
                type: 'pie',
                data: {
                    labels: Object.keys(wasteTypeCounts),
                    datasets: [{
                        data: Object.values(wasteTypeCounts),
                        backgroundColor: generateColors(Object.keys(wasteTypeCounts).length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right'
                        }
                    }
                }
            });
            
            // Weight Distribution Chart
            const weightRanges = {'0-50': 0, '51-100': 0, '101-150': 0, '151-200': 0, '201+': 0};
            mapData.points.forEach(point => {
                const weight = parseFloat(point.weight || 0);
                if (weight <= 50) weightRanges['0-50']++;
                else if (weight <= 100) weightRanges['51-100']++;
                else if (weight <= 150) weightRanges['101-150']++;
                else if (weight <= 200) weightRanges['151-200']++;
                else weightRanges['201+']++;
            });
            
            const weightCtx = document.getElementById('weightChart').getContext('2d');
            const weightChart = new Chart(weightCtx, {
                type: 'bar',
                data: {
                    labels: Object.keys(weightRanges),
                    datasets: [{
                        label: 'Number of Records',
                        data: Object.values(weightRanges),
                        backgroundColor: '#2D6A4F'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
            
            // Store chart references for updates
            window.wasteTypeChart = wasteTypeChart;
            window.weightChart = weightChart;
        }
        
        // Function to update charts based on filtered data
        function updateCharts() {
            if (!window.wasteTypeChart || !window.weightChart) return;
            
            // Update Waste Type Chart
            const wasteTypeCounts = {};
            filteredPoints.forEach(point => {
                const wasteType = point.waste_type.toLowerCase();
                wasteTypeCounts[wasteType] = (wasteTypeCounts[wasteType] || 0) + 1;
            });
            
            window.wasteTypeChart.data.labels = Object.keys(wasteTypeCounts);
            window.wasteTypeChart.data.datasets[0].data = Object.values(wasteTypeCounts);
            window.wasteTypeChart.data.datasets[0].backgroundColor = generateColors(Object.keys(wasteTypeCounts).length);
            window.wasteTypeChart.update();
            
            // Update Weight Distribution Chart
            const weightRanges = {'0-50': 0, '51-100': 0, '101-150': 0, '151-200': 0, '201+': 0};
            filteredPoints.forEach(point => {
                const weight = parseFloat(point.weight || 0);
                if (weight <= 50) weightRanges['0-50']++;
                else if (weight <= 100) weightRanges['51-100']++;
                else if (weight <= 150) weightRanges['101-150']++;
                else if (weight <= 200) weightRanges['151-200']++;
                else weightRanges['201+']++;
            });
            
            window.weightChart.data.datasets[0].data = Object.values(weightRanges);
            window.weightChart.update();
        }
        
        // Function to generate colors for charts
        function generateColors(count) {
            const colors = [
                '#2D6A4F', '#40916C', '#52B788', '#74C69D', '#95D5B2', 
                '#B7E4C7', '#D8F3DC', '#FF7F50', '#FFB74D', '#4FC3F7'
            ];
            
            if (count <= colors.length) {
                return colors.slice(0, count);
            }
            
            // If we need more colors, generate them
            const result = [...colors];
            for (let i = colors.length; i < count; i++) {
                const r = Math.floor(Math.random() * 200);
                const g = Math.floor(Math.random() * 200);
                const b = Math.floor(Math.random() * 200);
                result.push(`rgb(${r}, ${g}, ${b})`);
            }
            
            return result;
        }
        
        // Function to update data table based on filters
        function updateDataTable() {
            const rows = document.querySelectorAll('#dataTable tbody tr');
            const filterTagCodes = filteredPoints.map(p => p.tag_code);
            
            rows.forEach(row => {
                const tagCode = row.getAttribute('data-tag');
                if (filterTagCodes.includes(tagCode)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }
        
        // Create and update heatmap layer
        function updateHeatmap() {
            // Remove existing heatmap if present
            if (heatLayer && map.hasLayer(heatLayer)) {
                map.removeLayer(heatLayer);
            }
            
            // Create heatmap data points
            const heatData = filteredPoints.map(point => {
                // Higher weight values give more intensity
                const intensity = point.weight > 0 ? Math.min(point.weight / 10, 1) : 0.3;
                return [point.lat, point.lng, intensity];
            });
            
            // Create heatmap layer
            heatLayer = L.heatLayer(heatData, {
                radius: 25,
                blur: 15,
                maxZoom: 17
            });
            
            // Add to map
            map.addLayer(heatLayer);
        }
        
        // Create and update route layer
        function updateRoute() {
            // Remove existing route if present
            if (routeLayer && map.hasLayer(routeLayer)) {
                map.removeLayer(routeLayer);
            }
            
            // Sort points by timestamp
            const sortedPoints = [...filteredPoints].sort((a, b) => {
                return moment(a.timestamp).valueOf() - moment(b.timestamp).valueOf();
            });
            
            // Create line coordinates
            const routeCoords = sortedPoints.map(point => [point.lat, point.lng]);
            
            // Create polyline
            routeLayer = L.polyline(routeCoords, {
                color: '#2D6A4F',
                weight: 3,
                opacity: 0.7,
                dashArray: '5, 8',
                className: 'route-line'
            });
            
            // Add to map
            map.addLayer(routeLayer);
            
            // Update timeline
            initializeTimeline(sortedPoints);
        }
        
        // Initialize timeline control
        function initializeTimeline(sortedPoints) {
            if (sortedPoints.length === 0) return;
            
            const timeSlider = document.getElementById('timeSlider');
            const timeStart = document.getElementById('timeStart');
            const timeEnd = document.getElementById('timeEnd');
            const timelineInfo = document.getElementById('timelineInfo');
            
            // Set start and end times
            const startTime = moment(sortedPoints[0].timestamp);
            const endTime = moment(sortedPoints[sortedPoints.length - 1].timestamp);
            
            timeStart.textContent = startTime.format('YYYY-MM-DD HH:mm');
            timeEnd.textContent = endTime.format('YYYY-MM-DD HH:mm');
            
            // Handle slider change
            timeSlider.addEventListener('input', function() {
                const percent = this.value;
                showTimelinePosition(percent, startTime, endTime, sortedPoints);
            });
            
            // Play, pause, reset buttons
            let animationInterval;
            
            document.getElementById('playTimeline').addEventListener('click', function() {
                if (animationInterval) clearInterval(animationInterval);
                
                let currentPercent = parseInt(timeSlider.value);
                
                animationInterval = setInterval(() => {
                    currentPercent += 1;
                    if (currentPercent > 100) {
                        clearInterval(animationInterval);
                        return;
                    }
                    
                    timeSlider.value = currentPercent;
                    showTimelinePosition(currentPercent, startTime, endTime, sortedPoints);
                }, 250);
            });
            
            document.getElementById('pauseTimeline').addEventListener('click', function() {
                if (animationInterval) clearInterval(animationInterval);
            });
            
            document.getElementById('resetTimeline').addEventListener('click', function() {
                if (animationInterval) clearInterval(animationInterval);
                timeSlider.value = 0;
                showTimelinePosition(0, startTime, endTime, sortedPoints);
            });
        }
        
        // Show timeline position based on percentage
        function showTimelinePosition(percent, startTime, endTime, sortedPoints) {
            const totalMillis = endTime.valueOf() - startTime.valueOf();
            const currentMillis = (percent / 100) * totalMillis;
            const currentTime = moment(startTime.valueOf() + currentMillis);
            
            // Find points that should be visible at this time
            const visiblePoints = sortedPoints.filter(point => {
                const pointTime = moment(point.timestamp);
                return pointTime.valueOf() <= currentTime.valueOf();
            });
            
            // Update timeline info
            const timelineInfo = document.getElementById('timelineInfo');
            
            if (visiblePoints.length > 0) {
                const lastPoint = visiblePoints[visiblePoints.length - 1];
                const lastPointTime = moment(lastPoint.timestamp).format('YYYY-MM-DD HH:mm:ss');
                
                timelineInfo.innerHTML = `
                    <p><strong>Current Time:</strong> ${currentTime.format('YYYY-MM-DD HH:mm:ss')}</p>
                    <p><strong>Points Collected:</strong> ${visiblePoints.length} out of ${sortedPoints.length}</p>
                    <p><strong>Latest Collection:</strong> ${lastPoint.tag_code} (${lastPoint.waste_type}) at ${lastPointTime}</p>
                `;
            } else {
                timelineInfo.innerHTML = `
                    <p><strong>Current Time:</strong> ${currentTime.format('YYYY-MM-DD HH:mm:ss')}</p>
                    <p><strong>Points Collected:</strong> 0 out of ${sortedPoints.length}</p>
                    <p><strong>Latest Collection:</strong> None yet</p>
                `;
            }
            
            // Highlight the visible points on the map
            highlightTimelinePoints(visiblePoints);
        }
        
        // Highlight points on timeline
        function highlightTimelinePoints(visiblePoints) {
            // Reset all markers
            markersLayer.eachLayer(marker => {
                marker.setOpacity(0.5);
            });
            
            // Get tag codes of visible points
            const visibleTagCodes = visiblePoints.map(p => p.tag_code);
            
            // Highlight visible markers
            markersLayer.eachLayer(marker => {
                if (visibleTagCodes.includes(marker.options.alt)) {
                    // Highlight this marker
                    marker.setOpacity(1);
                }
            });
        }
        
        // CSV Export function
        function exportToCsv() {
            // Create CSV header
            let csv = 'Timestamp,Tag Code,Waste Type,Latitude,Longitude,Weight\n';
            
            // Add data rows for filtered points
            filteredPoints.forEach(point => {
                csv += `${point.timestamp},${point.tag_code},${point.waste_type},${point.lat},${point.lng},${point.weight}\n`;
            });
            
            // Create download link
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `emptying_data_export_${moment().format('YYYYMMDD_HHmmss')}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // === EVENT LISTENERS ===
        
        // Waste type filter badges
        document.querySelectorAll('#wasteTypeFilters .filter-badge, #mobileWasteTypeFilters .filter-badge').forEach(badge => {
            badge.addEventListener('click', function() {
                const wasteType = this.getAttribute('data-filter');
                
                // Update active state in UI
                document.querySelectorAll('#wasteTypeFilters .filter-badge, #mobileWasteTypeFilters .filter-badge').forEach(b => {
                    b.classList.remove('active');
                    if (b.getAttribute('data-filter') === wasteType) {
                        b.classList.add('active');
                    }
                });
                
                // Update filter and apply
                activeFilters.wasteType = wasteType;
                applyFilters();
            });
        });
        
        // Search input
        document.getElementById('searchTagCode').addEventListener('input', function() {
            activeFilters.searchText = this.value.trim();
            // Sync with mobile search
            document.getElementById('searchTagCodeMobile').value = this.value;
            applyFilters();
        });
        
        // Mobile search input
        document.getElementById('searchTagCodeMobile').addEventListener('input', function() {
            activeFilters.searchText = this.value.trim();
            // Sync with desktop search
            document.getElementById('searchTagCode').value = this.value;
            applyFilters();
        });
        
        // Table search
        document.getElementById('tableSearch').addEventListener('input', function() {
            const searchText = this.value.toLowerCase();
            const rows = document.querySelectorAll('#dataTable tbody tr');
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                let found = false;
                
                cells.forEach(cell => {
                    if (cell.textContent.toLowerCase().includes(searchText)) {
                        found = true;
                    }
                });
                
                row.style.display = found ? '' : 'none';
            });
        });
        
        // Initialize daterangepicker
        $('#daterange, #daterangeMobile').daterangepicker({
            opens: 'left',
            autoUpdateInput: false,
            locale: {
                cancelLabel: 'Clear',
                format: 'YYYY-MM-DD'
            }
        });
        
        // Handle date range selection
        $('#daterange, #daterangeMobile').on('apply.daterangepicker', function(ev, picker) {
            const startDate = picker.startDate;
            const endDate = picker.endDate;
            
            // Update both inputs
            $('#daterange, #daterangeMobile').val(startDate.format('YYYY-MM-DD') + ' - ' + endDate.format('YYYY-MM-DD'));
            
            // Update filter and apply
            activeFilters.dateRange = [startDate, endDate];
            applyFilters();
        });
        
        // Handle date range clear
        $('#daterange, #daterangeMobile').on('cancel.daterangepicker', function() {
            // Clear both inputs
            $('#daterange, #daterangeMobile').val('');
            
            // Reset filter and apply
            activeFilters.dateRange = null;
            applyFilters();
        });
        
        // Weight range slider
        document.getElementById('weightRangeSlider').addEventListener('input', function() {
            const value = parseInt(this.value);
            activeFilters.weightMin = value;
            document.getElementById('minWeight').textContent = value;
            document.getElementById('weightRangeSliderMobile').value = value;
            document.getElementById('minWeightMobile').textContent = value;
            applyFilters();
        });
        
        // Mobile weight range slider
        document.getElementById('weightRangeSliderMobile').addEventListener('input', function() {
            const value = parseInt(this.value);
            activeFilters.weightMin = value;
            document.getElementById('minWeightMobile').textContent = value;
            document.getElementById('weightRangeSlider').value = value;
            document.getElementById('minWeight').textContent = value;
            applyFilters();
        });
        
        // Toggle clustering
        document.getElementById('clusterToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            document.getElementById('clusterToggleMobile').classList.toggle('active');
            
            if (this.classList.contains('active')) {
                // Enable clustering
                if (!map.hasLayer(markersLayer)) {
                    map.addLayer(markersLayer);
                }
            } else {
                // Disable clustering
                if (map.hasLayer(markersLayer)) {
                    map.removeLayer(markersLayer);
                    
                    // Add individual markers
                    filteredPoints.forEach(point => {
                        const marker = point.marker;
                        if (marker) {
                            map.removeLayer(marker);
                        }
                    });
                }
            }
        });
        
        // Mobile clustering toggle
        document.getElementById('clusterToggleMobile').addEventListener('click', function() {
            document.getElementById('clusterToggle').click();
        });
        
        // Toggle heatmap
        document.getElementById('heatmapToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            document.getElementById('heatmapToggleMobile').classList.toggle('active');
            
            if (this.classList.contains('active')) {
                // Enable heatmap
                updateHeatmap();
            } else {
                // Disable heatmap
                if (heatLayer && map.hasLayer(heatLayer)) {
                    map.removeLayer(heatLayer);
                }
            }
        });
        
        // Mobile heatmap toggle
        document.getElementById('heatmapToggleMobile').addEventListener('click', function() {
            document.getElementById('heatmapToggle').click();
        });
        
        // Toggle route
        document.getElementById('routeToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            document.getElementById('routeToggleMobile').classList.toggle('active');
            
            if (this.classList.contains('active')) {
                // Enable route
                updateRoute();
            } else {
                // Disable route
                if (routeLayer && map.hasLayer(routeLayer)) {
                    map.removeLayer(routeLayer);
                }
            }
        });
        
        // Mobile route toggle
        document.getElementById('routeToggleMobile').addEventListener('click', function() {
            document.getElementById('routeToggle').click();
        });
        
        // Reset filters
        document.getElementById('resetFilters').addEventListener('click', function() {
            // Reset filter values
            activeFilters = {
                wasteType: 'all',
                dateRange: null,
                weightMin: 0,
                weightMax: 300,
                searchText: ''
            };
            
            // Reset UI elements
            document.querySelectorAll('#wasteTypeFilters .filter-badge, #mobileWasteTypeFilters .filter-badge').forEach(badge => {
                badge.classList.remove('active');
                if (badge.getAttribute('data-filter') === 'all') {
                    badge.classList.add('active');
                }
            });
            
            document.getElementById('searchTagCode').value = '';
            document.getElementById('searchTagCodeMobile').value = '';
            document.getElementById('daterange').value = '';
            document.getElementById('daterangeMobile').value = '';
            document.getElementById('weightRangeSlider').value = 0;
            document.getElementById('weightRangeSliderMobile').value = 0;
            document.getElementById('minWeight').textContent = '0';
            document.getElementById('minWeightMobile').textContent = '0';
            
            // Apply filters
            applyFilters();
        });
        
        // Mobile reset filters
        document.getElementById('resetFiltersMobile').addEventListener('click', function() {
            document.getElementById('resetFilters').click();
        });
        
        // CSV Export
        document.getElementById('exportCsv').addEventListener('click', exportToCsv);
        
        // Fullscreen toggle
        document.getElementById('toggleFullscreen').addEventListener('click', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.fullscreenElement) {
                if (mapContainer.requestFullscreen) {
                    mapContainer.requestFullscreen();
                } else if (mapContainer.mozRequestFullScreen) {
                    mapContainer.mozRequestFullScreen();
                } else if (mapContainer.webkitRequestFullscreen) {
                    mapContainer.webkitRequestFullscreen();
                } else if (mapContainer.msRequestFullscreen) {
                    mapContainer.msRequestFullscreen();
                }
                this.innerHTML = '<i class="fas fa-compress me-1"></i>Exit Fullscreen';
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                this.innerHTML = '<i class="fas fa-expand me-1"></i>Fullscreen';
            }
            
            // Resize map after transition
            setTimeout(() => {
                map.invalidateSize();
            }, 400);
        });
        
        // Add attribution control in custom position
        L.control.attribution({
            position: 'bottomleft'
        }).addTo(map);
    });
</script>
{% endblock %} 